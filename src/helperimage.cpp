// SPDX-FileCopyrightText: Lukas Sommer <sommerluk@gmail.com>
// SPDX-License-Identifier: BSD-2-Clause OR MIT

// Own header
#include "helperimage.h"

#include "asyncimagerendercallback.h"
#include "cielchd50values.h"
#include "helperconstants.h"
#include "helpermath.h"
#include "helperqttypes.h"
#include "interlacingpass.h"
#include "rgbcolorspace.h"
#include <lcms2.h>
#include <qcolor.h>
#include <qimage.h>
#include <qmath.h>
#include <qnamespace.h>
#include <qpainter.h>
#include <qrgb.h>
#include <qsharedpointer.h>
#include <qsize.h>
#include <type_traits>

namespace PerceptualColor
{

/**
 * @brief Find boundaries between fully opaque and fully transparent pixels.
 *
 * @param image The image to be searched.
 *
 * @note There is no API guarantee regarding the handling of partially
 * transparent pixels — they may be treated as fully opaque or
 * fully transparent.
 *
 * @returns A list of all coordinate points on both sides of the boundary.
 *
 * @note This function is thread-save as long as there is no more than one
 * thread of this function operating on the same data on the same time.
 */
QList<QPoint> findBoundary(const QImage &image)
{
    QList<QPoint> coordinates;
    int width = image.width();
    int height = image.height();
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (image.pixelColor(x, y).alpha() != 0) { // gamut body
                // We process only the pixels of the gamut body. A gamut body
                // pixel is added if at least one of its neighbors is a
                // background pixel, along with all neighboring background
                // pixels. This eliminates the need for a second pass to test
                // background pixels.
                // NOTE: The background color may occasionally appear within
                // the gamut body, but such instances are rare and therefore
                // not computationally expensive to handle. In these cases,
                // anti-aliasing has no effect, making it inconsequential to
                // the final image.
                bool hasTransparentNeighbor = false;
                // Check 8 neighbors
                for (int dy = -1; dy <= 1; ++dy) {
                    for (int dx = -1; dx <= 1; ++dx) {
                        if (dx == 0 && dy == 0) {
                            continue; // Skip the pixel itself
                        }
                        const auto xOutOfRange = //
                            ((x + dx < 0) || (x + dx >= image.width()));
                        const auto yOutOfRange = //
                            ((y + dy < 0) || (y + dy >= image.height()));
                        if (xOutOfRange || yOutOfRange) {
                            // Out of range
                            continue;
                        }
                        const auto myPixelColor = //
                            image.pixelColor(x + dx, y + dy);
                        if (myPixelColor.alpha() == 0) {
                            hasTransparentNeighbor = true;
                            const QPoint myNeighbor = QPoint(x + dx, y + dy);
                            if (!coordinates.contains(myNeighbor)) {
                                // Add transparent pixel
                                coordinates.append(myNeighbor);
                            }
                        }
                    }
                }
                if (hasTransparentNeighbor) {
                    const auto gamutPixel = QPoint(x, y);
                    if (!coordinates.contains(gamutPixel)) {
                        // Add the gamut body pixel itself
                        coordinates.append(gamutPixel);
                    }
                }
            }
        }
    }
    return coordinates;
}

/**
 * @brief Calculates anti-alias for gamut diagrams.
 *
 * Gamut images generated by this library typically exhibit sharp boundaries,
 * where a pixel is either within the gamut (opaque color) or outside it
 * (transparent color). The determination is based on the coordinates at the
 * center of the pixel's square surface.
 *
 * This function is designed to perform anti-aliasing by smoothing the sharp
 * gamut boundaries. To use this function, first obtain a list of candidate
 * pixels for anti-aliasing. These are the pixels surrounding the sharp gamut
 * border, which can be identified using @ref findBoundary(). This function
 * then calculates, within the 1 px × 1 px area of each candidate pixel,
 * multiple data points at a significantly higher resolution than the single
 * data point in the original image. By analyzing this detailed data, the
 * function applies anti-aliasing to smooth the boundary.
 *
 * @note Since this operation is computationally intensive, it is recommended
 * to apply it only to the pixels returned by @ref findBoundary(), rather than
 * the entire image.
 *
 * @param image The image that should be modified.
 * @param antiAliasCoordinates A list of pixels for which anti-aliasing should
 *        be done.
 * @param colorFunction A pointer to a function that returns the opaque color
 *        for the given coordinates, or a transparent color if out-of-gamut.
 */
void doAntialias(QImage &image, const QList<QPoint> &antiAliasCoordinates, const std::function<QRgb(const double x, const double y)> &colorFunction)
{
    QList<QColor> opaqueColors;
    for (const auto myValue : antiAliasCoordinates) {
        // Iterating over a square grid of data points within the given pixel.
        // The side length of the square contains exactly “sideLength” data
        // points. Its square represents the total number of data points,
        // referred to here as “totalDataPoints”. The“ sideLength” is chosen so
        // that the total number of data points is 256, corresponding to the
        // number of possible alpha values in typical 4-byte colors
        // (RGB+Alpha), which is sufficient for this case."
        constexpr int sideLength = 16;
        constexpr int totalDataPoints = sideLength * sideLength;
        opaqueColors.clear();
        opaqueColors.reserve(totalDataPoints);
        constexpr double stepWidth = 1.0 / sideLength;
        double x = myValue.x() - 0.5 + stepWidth / 2;
        double y = myValue.y() - 0.5 + stepWidth / 2;
        for (int i = 0; i < sideLength; ++i) {
            for (int j = 0; j < sideLength; ++j) {
                const QRgb tempColor = colorFunction(x + i * stepWidth, //
                                                     y + j * stepWidth);
                if (qAlpha(tempColor) != 0) {
                    opaqueColors.append(tempColor);
                }
            }
        }
        if (opaqueColors.count() > 0) {
            const QColorFloatType countF = //
                static_cast<QColorFloatType>(opaqueColors.count());
            QColor newPixel = image.pixelColor(myValue);
            if (newPixel.alpha() == 0) {
                // The center of the pixel is out-of-gamut. For anti-aliasing,
                // we need a color, so we calculate the mean color of all other
                // data points within the pixel that actually are in-gamut.
                QColorFloatType r = 0;
                QColorFloatType g = 0;
                QColorFloatType b = 0;
                for (const QColor &myColor : opaqueColors) {
                    r += myColor.redF();
                    g += myColor.greenF();
                    b += myColor.blueF();
                }
                r /= countF;
                g /= countF;
                b /= countF;
                newPixel = QColor::fromRgbF(r, g, b);
            }
            newPixel.setAlphaF(countF / totalDataPoints);
            image.setPixelColor(myValue, newPixel);
        }
    }
}

} // namespace PerceptualColor
